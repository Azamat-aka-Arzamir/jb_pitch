<!DOCTYPE html>
<html lang="en">

<head>
	<title>Jelly Button demo</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<link rel="stylesheet" type="text/css" href="../style.css">
	<link rel="preconnect" href="https://fonts.googleapis.com">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link href="https://fonts.googleapis.com/css2?family=Yusei+Magic&display=swap" rel="stylesheet">
	<style>
		.yusei-magic-regular {
			font-family: "Yusei Magic", sans-serif;
			font-weight: 400;
			font-style: normal;
		}


		/* full-viewport overlay that sits above everything */
		.overlay {
			position: fixed;
			inset: 0;
			/* top:0; right:0; bottom:0; left:0 */
			display: flex;
			align-items: top;
			justify-content: center;
			z-index: 2000;
			/* very high so it's above other elements */
			pointer-events: none;
			/* allow clicks to pass through (remove if you need to interact) */
			background: transparent;
			top: 0;
			user-select: none;
			/* keep background transparent so image alpha shows page under it */
		}

		/* responsive image that preserves transparency */
		.overlay img {
			max-width: 100%;
			max-height: 100%;
			width: auto;
			height: auto;
			object-fit: contain;
			display: block;
		}

		.stretch-x img {
			width: 100%;
			/* fill screen horizontally */
			height: auto;
			/* keep aspect ratio */
			max-width: none;
			object-fit: fill;
			/* remove max constraint */
		}

		body::-webkit-scrollbar {
			display: none;
			/* Chrome, Safari */
		}

		body {
			background-color: black;
		}

		.bebra {
			position: absolute;
			display: flex;
			width: 100%;
			height: 100%;
			pointer-events: none;
		}

		.bebra * {
			width: 100%;
			z-index: 3000;
			pointer-events: none;
		}

		@media (max-width: 768px) {
			.bebra {
				display: none;
			}
		}
	</style>
	<script type="module" crossorigin src="./dist-9/assets/index-BR0qgEVN.js"></script>
</head>

<body>
	<div style="position: absolute;top:0;margin-top: 0;height: 300vh;width: 10px;"></div>
	<div class="overlay stretch-x" aria-hidden="true" style="position: absolute;">
		<img src="./html/overlay.png" alt="overlay">
	</div>
	<div class="overlay stretch-x" aria-hidden="true" style="position: absolute;top:85vh;height:15vh;">
		<img src="./html/second_overlay.png" alt="overlay">
	</div>
	<div class="overlay stretch-x" aria-hidden="true" style="position: absolute;top:200vh;height:35vh;">
		<img src="./html/third_overlay.png" alt="overlay">
	</div>

	<div class="bebra yusei-magic-regular">
		<h1></h1>
	</div>

	<div class="overlay" aria-hidden="true">
		<img src="./html/text.png" alt="overlay">
	</div>
	<div id="container" style="width: 100%;height: 100vh;">Loading...</div>

	<script src="./js/three/three.min.js"></script>
	<script src="./js/three/OrbitControls.js"></script>
	<script src="./js/three/OBJLoader.js"></script>
	<script src="./js/three/BufferGeometryUtils.js"></script>
	<script src="./js/three/WebGL.js"></script>
	<script src="./js/three/stats.min.js"></script>
	<script src="./js/example.js"></script>
	<script src="./js/soft-body-creator.js"></script>
	<canvas id="wowaser" style="margin-top:calc(125vh + (50vh / 2 - 50%));width: 100%;z-index: 90;"></canvas>
	<div id="iceOverlay"
		style="pointer-events: none;position: absolute;background: radial-gradient(circle, transparent,transparent,transparent,transparent,#285378,#285378,#285378);width: 100px;height: 100px;z-index: 1000;">
	</div>
	<div id="iceUnderlay"
		style="pointer-events: none;position: absolute;background-color: #285378;width: 100vw;height: 100vh;z-index: 0;top:100vh">
	</div>


	<script type="module">
		// In case you haven't built the library yourself, replace URL with: https://www.unpkg.com/jolt-physics/dist/jolt-physics.wasm-compat.js
		import initJolt from 'https://www.unpkg.com/jolt-physics/dist/jolt-physics.wasm-compat.js';
		import { glassMat } from "./utils.js";

		const ice = document.getElementById("wowaser")
		const iceOverlay = document.getElementById("iceOverlay")
		function resizeOverlay() {
			let s = getComputedStyle(ice);
			iceOverlay.style.top = (parseFloat(s.marginTop) + 16) + "px";
			iceOverlay.style.width = s.width;
			iceOverlay.style.height = s.height;
		}
		resizeOverlay();

		iceOverlay.style.width = (parseInt(iceOverlay.style.width) + 42) + "px";
		iceOverlay.style.height = (parseInt(iceOverlay.style.height) + 42) + "px";
		iceOverlay.style.top = (parseFloat(iceOverlay.style.top) - 21) + "px";
		setTimeout(resizeOverlay, 1000)
		window.onresize = resizeOverlay
		const jelly = {
			color: 0xffffff,
			transmission: 0.9,
			opacity: 0.7,
			metalness: 0,
			roughness: 0.2,
			ior: 2.5,
			thickness: 2.5,
			attenuationColor: 0xffffff,
			attenuationDistance: 0.25,
			specularIntensity: 1,
			specularColor: 0xffffff,
			lightIntensity: 1,
			exposure: 1
		};
		var jellyCubeVertices = {}
		initJolt().then(async function (Jolt) {
			// Initialize this example
			initExample(Jolt, null);

			const texLoader = new window.THREE.TextureLoader();

			createFloor(16);
			const floor = dynamicObjects[dynamicObjects.length - 1];
			await texLoader.load(
				'./html/jelly.png',
				(texture) => {
					texture.encoding = THREE.sRGBEncoding;
					texture.needsUpdate = true;
					texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
					texture.repeat.set(1, 1); // adjust as needed
					const material = new THREE.MeshPhongMaterial({
						map: texture, color: 0xffffff, shininess: 0,        // removes highlight completely
						specular: new THREE.Color(0x000000),
					});
					floor.material = material;
					floor.material.needsUpdate = true;
				},
				undefined,
				(err) => console.error('Texture failed to load', err)
			);
			const position = new Jolt.RVec3();
			const rotAxis = new Jolt.Vec3(1, 0, 0);
			const rotation = Jolt.Quat.prototype.sRotation(rotAxis, -Math.PI / 4 * 0);
			// Create shared settings
			const sharedSettings = SoftBodyCreator.CreateCube(15, 0.2, 10e-8, 10e-8);

			position.Set(0, .5, 0)



			//cube_vertex.at(i).mVelocity.z = 100;

			const bodyCreationSettings = new Jolt.SoftBodyCreationSettings(sharedSettings, position, rotation, LAYER_MOVING);
			bodyCreationSettings.mGravityFactor = 0
			bodyCreationSettings.mPressure = 2;
			bodyCreationSettings.mFriction = 100;
			bodyCreationSettings.mObjectLayer = LAYER_MOVING;
			const body = bodyInterface.CreateSoftBody(bodyCreationSettings);

			addToScene(body, 0xffffff);

			Jolt.destroy(bodyCreationSettings);
			var mesh = dynamicObjects[dynamicObjects.length - 1];
			const jellyMaterial = new THREE.MeshPhysicalMaterial({
				/*color: new THREE.Color(0xDDB13), // pinkish jelly color
				transparent: true,
				opacity: 0.6,                  // soft transparency
				transmission: 0.1,             // glass-like transmission
				roughness: 0.1,                // smooth surface
				metalness: 0,                   // non-metallic
				clearcoat: 1.0,                 // adds extra shine
				clearcoatRoughness: 0.05,       // smooth glossy finish
				reflectivity: 0.5,             // reflections
				ior: 1.33,                      // index of refraction (like jelly / water)
				specularIntensity: 1.0,*/
				color: 0xffffff,
				transmission: 2.8,
				opacity: 0.1,
				metalness: 0,
				roughness: 0.0,
				ior: 2.5,
				thickness: 1.8,
				attenuationColor: 0xffffff,
				attenuationDistance: 1.5,
				specularIntensity: 0.06,
				specularColor: 0xffffff,
				lightIntensity: .02,
				exposure: 1,
				transparent: false,
			});

			// Fresnel effect using onBeforeCompile for subtle edge glow
			jellyMaterial.onBeforeCompile = (shader) => {
				shader.fragmentShader = shader.fragmentShader.replace(
					`#include <dithering_fragment>`,
					`
        				#include <dithering_fragment>

       					 // Fresnel edge glow
						float fresnel = pow(1.0 - dot(normalize(vViewPosition), normal), 2.0);
        				vec3 fresnelColor = vec3(0.3, 1.0, 0.0) * fresnel * 0.7; // subtle white edges
						gl_FragColor.rgb += fresnelColor;
        				`
				);
			};

			jellyMaterial.side = THREE.DoubleSide; // show both sides for transparent jel
			const [r, g, b] = [1, 1, 1];
			jellyMaterial.attenuationColor.setRGB(r, g, b);
			mesh.material = jellyMaterial;
			mesh.material.needsUpdate = true;
			scene.remove(mesh)
			async function createGelCube(edgeCompliance, volumeCompliance, x, y, z, color) {

				camera.position.y -= 4;
				camera.position.z -= 4;
				camera.position.set(0, 15, 12);
				camera.lookAt(new THREE.Vector3(0, 0, -2));
				camera.fov = 50
				camera.updateProjectionMatrix();
				scene.add(mesh)
				scene.add(floor)
				mesh = dynamicObjects[dynamicObjects.length - 1];

				document.getElementById("container").style.marginTop = "0"
				document.getElementById("container").style.top = "0px"
				dirLight.intensity = 0
				ambient.intensity = 0.7
				//



				jellyCubeVertices = Jolt.castObject(body.GetMotionProperties(), Jolt.SoftBodyMotionProperties).GetVertices();
				const vertCopy = []
				const startPos = []
				for (let i = 0; i < jellyCubeVertices.size(); i++) {
					vertCopy.push(jellyCubeVertices.at(i))
					startPos.push({
						x: jellyCubeVertices.at(i).mPosition.GetX(),
						y: jellyCubeVertices.at(i).mPosition.GetY(),
						z: jellyCubeVertices.at(i).mPosition.GetZ(),
					})
				}

				var minY = Infinity;
				var maxY = -Infinity;
				vertCopy.forEach(element => {
					if (element.mPosition.GetY() < minY) minY = element.mPosition.GetY()
					if (element.mPosition.GetY() > maxY) maxY = element.mPosition.GetY()
					//e.mInvMass = 1
				});
				const staticVerts = vertCopy.filter(e => e.mPosition.GetY() == minY)
				const shakyVerts = vertCopy.filter(e => e.mPosition.GetY() == maxY)
				staticVerts.forEach(e => e.mInvMass = 0)
				var h = false;

				document.body.onpointerdown = (() => {
					bodyInterface.ActivateBody(body.GetID())
					staticVerts.forEach(e => {
						//e.mPosition.SetZ(e.mPosition.GetZ()*1.5)
						//e.mVelocity.SetZ(-100)
					});
					h = true
					point.intensity = .6;
					console.log(body.IsActive())
					Jolt.castObject(body.GetMotionProperties(), Jolt.SoftBodyMotionProperties).SetGravityFactor(0)
				})
				document.body.onpointerup = (() => {
					bodyInterface.ActivateBody(body.GetID())
					staticVerts.forEach(e => {
						//e.mPosition.SetZ(e.mPosition.GetZ()/1.5)
						//e.mVelocity.SetZ(-100)
					});
					h = false
					point.intensity = 0;
					console.log(body.IsActive())
					Jolt.castObject(body.GetMotionProperties(), Jolt.SoftBodyMotionProperties).SetGravityFactor(0)
				})

				let lastMousePos = { x: 0, y: 0 };
				let lastAccel = { accX: 0, accZ: 0 }
				var delta = { x: 0, y: 0 }
				let sync = true;
				window.addEventListener('mousemove', (event) => {
					// Current mouse position
					const currentMousePos = { x: event.clientX, y: event.clientY };

					// Calculate delta vector
					delta = {
						x: currentMousePos.x - lastMousePos.x,
						y: currentMousePos.y - lastMousePos.y
					};

					//console.log('Mouse delta:', delta);

					// Update last mouse position
					lastMousePos = currentMousePos;
				});
				window.addEventListener('devicemotion', (event) => {
					if (!sync) return;
					const acc = event.accelerationIncludingGravity;
					if (!acc) return;
					delta.accX = (acc.x ?? 0);
					//this.#accY = acc.y ?? 0;
					delta.accZ = (acc.z ?? 0);
					lastAccel = { accX: acc.x ?? 0, accZ: acc.z ?? 0 }
					sync = false
				});
				onUpdate = () => {

					//alert(delta.accX?delta.accX:0)
					mesh.geometry.computeVertexNormals();
					mesh.geometry.normalsNeedUpdate = true;
					bodyInterface.ActivateBody(body.GetID())

					shakyVerts.forEach(e => {
						e.mVelocity.Set(delta.x / 1 + (delta.accX ? delta.accX : 0) * -120, e.mVelocity.GetY(), delta.y / 1 + (delta.accX ? delta.accZ : 0) * -120)
					});
					delta = { x: 0, y: 0, accX: 0, accZ: 0 }
					if (h) {
						vertCopy.filter(e => !staticVerts.includes(e)).forEach((e, i) => {

							//e.mVelocity.SetZ((e.mPosition.GetZ()) * 30)
							if (Math.abs(e.mPosition.GetX()) < 20) {

								e.mVelocity.SetY(-2 * (2 - Math.abs(e.mPosition.GetX())))
								if (e.mPosition.GetY() < .2) {
									e.mVelocity.SetX((startPos[i].x) * 20)
									//e.mVelocity.SetZ((startPos[i].z) * 20 )
								}

							}
							else {
								//e.mVelocity.SetY(2*(Math.abs(e.mPosition.GetX())))
								//e.mVelocity.SetX((e.mPosition.GetX()) * 5*(1))
							}
						});
					}
					sync = true
				}
				return [mesh, floor, texLoader];
			}

			// Compliance in constraints are calculated here in 10^negative values and are inverse-values, so closer to 0 is closer to infinity
			// These will be very, very small floating values to maintain cube-like structure
			// Most values of even 10e-3 (0.0001) are too large to maintain structural integrity and we need to go even smaller towards -7 or -8
			await createGelCube(10e-8, 10e-8, 0, 0.5, 0, [1, 1, 1]);
			const geometry = new THREE.BoxGeometry(35, 22, 10);
			const material_cube = new THREE.MeshBasicMaterial({ color: 0x888888 });
			const cubebg = new THREE.Mesh(geometry, material_cube);
			const loader = new THREE.OBJLoader();
			const object = await loader.loadAsync('./untitled.obj');
			object.traverse((child) => {
				if (child.isMesh) {
					child.material = glassMat;
				}
			});
			object.rotateY(-Math.PI / 2);
			const drops = [object.clone(), object.clone(), object.clone(), object.clone(), object.clone(), object.clone(), object.clone(), object.clone(), object.clone(), object.clone(), object.clone()]

			await texLoader.load(
				'./html/lorem.png',
				(texture) => {
					texture.encoding = THREE.sRGBEncoding;
					texture.needsUpdate = true;
					texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
					texture.repeat.set(1, 1); // adjust as needed
					const material = new THREE.MeshPhongMaterial({
						map: texture, color: 0xffffff, shininess: 0,        // removes highlight completely
						specular: new THREE.Color(0x000000),
					});
					cubebg.material = material;
					cubebg.material.needsUpdate = true;

				},
				undefined,
				(err) => console.error('Texture failed to load', err)
			);
			async function newScene() {
				document.getElementById("container").style.marginTop = "200vh"
				dirLight.intensity = 1.5
				ambient.intensity = 0
				camera.fov = 40
				camera.updateProjectionMatrix();
				scene.remove(floor)
				console.log(mesh)
				console.log(floor)
				console.log(texLoader)
				scene.remove(mesh)

				cubebg.position.set(-8, 5, -5)

				scene.add(cubebg);
				camera.position.set(8, 5, 10);
				camera.lookAt(new THREE.Vector3(-5, 5, -7));

				//finalMesh.material = glassMat;
				//finalMesh.material.needsUpdate = true;

				//scene.add(object);

				let offsets = []
				drops.forEach((e, i) => {
					scene.add(e);
					offsets[i] = { offset: Math.random() * 12, speed: Math.random() * 200 + 200 };
				})
				onUpdate = () => {
					drops.forEach((e, i) => {
						e.position.set((i - drops.length / 2) * 1, (-Date.now() / offsets[i].speed + offsets[i].offset) % 12 + 12, 0)
					})

				}
				return [cubebg, drops]
			}
			var f = false;
			window.onscroll = async (e) => {
				const progress = window.scrollY /
					(document.documentElement.scrollHeight - window.innerHeight);
				if (progress > .5 && !f) {

					await newScene()
					f = true;
				}
				if (progress > 0) {
					window.somevar = 1
				}
				if (progress < .5 && f) {
					f = false
					await createGelCube(10e-8, 10e-8, 0, 0.5, 0, [1, 1, 1]);
					if (cubebg) scene.remove(cubebg)
					if (drops) drops.forEach(e => scene.remove(e))
				}
			}

		});
	</script>

</body>

</html>